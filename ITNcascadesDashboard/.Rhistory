theme(
strip.background = element_blank(),
strip.text = element_blank(),
legend.background = element_blank(),
legend.box.background = element_rect(colour = "black"),
legend.margin = margin(t = 0, b = 1, r=3, l=1),
axis.text=element_text(size=12),
axis.title=element_text(size=14), legend.text = element_text(size=15),
legend.title = element_text(size=15),
plot.title = element_text(size = 18),panel.spacing = unit(2, "lines")
)+ggtitle(title)
if(! legend){
p=p+
theme(legend.position = "none")
}
if(! is.null(breaks)){
p=p+
scale_x_continuous(breaks = breaks)
}
return(p)
}
# plots
plot_mosha_full_match=plot_results_function(myRCT="Mosha et al.", agegroup="(6 months to 14 years old)",title="A. Mosha et al. 2022, 2024",legend=T)
plot_mosha_match=plot_mosha_full_match+
theme(legend.position = "none")
plot_protopopoff_match=plot_results_function(myRCT="Protopopoff et al.", agegroup="(6 months to 14 years old)",title="B. Protopopoff et al. 2018, 2023")
plot_staedke_match=plot_results_function(myRCT="Staedke et al.", agegroup="(2 to 10 years old)",title="D. Staedke et al. 2020", breaks=c(2017, 2018, 2019))
plot_accrombessi_match=plot_results_function(myRCT="Accrombessi et al.", agegroup="(all ages)",title="C. Accrombessi et al. 2023, 2024", colors=c( "darkgrey","orange"))
grobs <- ggplotGrob(plot_mosha_full_match)$grobs
legend <- grobs[[which(sapply(grobs, function(x) x$name) == "guide-box")]]
plot_line2=plot_grid(plot_protopopoff_match, legend, ncol=2, rel_widths = c(2/3, 1/3))
plot_line3=plot_grid(plot_accrombessi_match, plot_staedke_match, ncol=2, rel_widths = c(1, 1))
plot_all_match=plot_grid(plot_mosha_match, plot_line2, plot_line3, ncol=1)
plot_all_match
# ON PREVALENCE
validat_pooledAll %>%
ungroup()%>%unique()%>%
left_join( results_pooled) %>%
mutate(maxmin=pmax(PR_mini,PR_obs_min),
minmax=pmin(PR_maxi,PR_obs_max),
overlap=(maxmin<= minmax))%>%
View()
regdat_match=validat_pooledAll %>%
left_join( results_pooled)
# check whether intervals overlap
interval_overlap=regdat_match %>%
mutate(overlap1=(PR_obs_min<=PR_maxi & PR_obs_min>=PR_mini),
overlap2=(PR_obs_max<=PR_maxi & PR_obs_max>=PR_mini),
overlap=(overlap1|overlap2))%>%
select(RCT, setting, year, month, overlap)
interval_overlap %>% group_by(setting)%>% summarise(true=sum(as.numeric(!overlap)), tot=n())
# regression model
model_PR <- lm(PR_obs ~ PR_middle+0,
data=regdat_match)
summary(model_PR)
Rsquared <- round(summary(model_PR)$adj.r.squared,2)
Rsquared
slope_PR <- round(summary(model_PR)$coefficients[1],2)
scatter_PR=validat_pooledAll %>%
left_join( results_pooled) %>%
ggplot()+
geom_point(aes(x=PR_obs*100, y=PR_middle*100, color=setting, shape=RCT), size=2)+
geom_linerange(aes(y=PR_middle*100, xmin=PR_obs_min*100, xmax=PR_obs_max*100, color=setting))+
geom_linerange(aes(ymin=PR_mini*100, x=PR_obs*100, ymax=PR_maxi*100, color=setting))+
scale_color_manual(values=c( "darkgrey", "dodgerblue","orange"))+
geom_abline(slope=1, intercept = 0, linetype="dashed")+
#geom_abline(slope=slope_PR, intercept = 0)+
theme_minimal()+xlim(0,100)+ylim(0,100)+labs(color="", y='Modelled prevalence', x="Observed prevalence", shape="")+
theme(legend.position = "right", legend.box="vertical")
observation_dates_validation=validat_pooledAll %>% select(RCT, year, month)%>% unique()
results_filter=results_pooled_perPyrethroid %>% right_join(observation_dates_validation)
eff_size_model_match=results_filter %>% filter(setting =="Pyrethroid-only") %>% rename("PR_mini_control"="PR_mini","PR_maxi_control"="PR_maxi","PR_middle_control"="PR_middle") %>%
ungroup()%>% dplyr::select(-setting)%>%
left_join(results_filter %>% filter(setting !="Pyrethroid-only"))%>%
mutate(effect_size=100*(PR_middle_control-PR_middle )/PR_middle_control)
eff_size_model_match_pool=eff_size_model_match%>% group_by(RCT, setting, year, month)%>%
summarise(effect_size=median(effect_size, na.rm = T) )
eff_size_data=validat_pooledAll %>% filter(setting =="Pyrethroid-only") %>% rename("PR_obs_min_control"="PR_obs_min","PR_obs_max_control"="PR_obs_max","PR_obs_control"="PR_obs") %>% ungroup()%>% dplyr::select(age, year, month, RCT, PR_obs_min_control, PR_obs_max_control, PR_obs_control)%>%
unique()%>%
left_join(validat_pooledAll %>% filter(setting !="Pyrethroid-only") %>% select(-setting0)%>% unique())%>%
mutate(effect_size_obs=100*(PR_obs_control-PR_obs)/PR_obs_control)%>%
filter(status=="Validation points")
reg_effsize_match=eff_size_data %>% left_join(eff_size_model_match_pool) %>% select(RCT, year, month, setting,effect_size, effect_size_obs )
model_effsize <- lm(effect_size_obs ~ effect_size +0,
data=reg_effsize_match)
summary(model_effsize)
Rsquared_effsize <- round(summary(model_effsize)$adj.r.squared,2)
Rsquared_effsize
slope_effsize<- round(summary(model_effsize)$coefficients[1],2)
scatter_effsize=eff_size_data %>% left_join(eff_size_model_match_pool) %>%
ggplot()+
geom_point(aes(y=effect_size, x=effect_size_obs, color=setting, shape=RCT), size=2)+
scale_color_manual(values=c( "dodgerblue","orange"))+xlim(-10,100)+ ylim(0,100)+
geom_abline(slope=1, intercept = 0, linetype="dashed")+
#geom_abline(slope=slope_effsize, intercept = 0)+
theme_minimal()+xlim(0,100)+ylim(0,100)+
labs(color="", y='Modelled effect size', x="Observed effect size",shape="")+
theme(legend.position = "right")
observation_dates_all=rbind(fitdat_pooledAll %>% mutate(status="baseline"),validat_pooledAll %>%mutate(status="post")) %>% select(RCT, setting, year, month, status)%>% unique()
results_filter_all=results_pooled_perPyrethroid %>% right_join(observation_dates_all)
before_after_match=results_filter_all %>% filter(status =="baseline") %>% rename("PR_mini_baseline"="PR_mini","PR_maxi_baseline"="PR_maxi","PR_middle_baseline"="PR_middle") %>%
ungroup()%>% dplyr::select(-month, -year, -status)%>%
left_join(results_filter_all %>% filter(status=="post"))%>%
mutate(effect_size=100*(PR_middle_baseline-PR_middle )/PR_middle_baseline)
before_after_match_pool=before_after_match%>% group_by(RCT, setting, year, month)%>%
summarise(effect_size=median(effect_size, na.rm = T) )
before_after_data=fitdat_pooledAll %>% rename("PR_obs_min_baseline"="PR_obs_min","PR_obs_max_baseline"="PR_obs_max","PR_obs_baseline"="PR_obs") %>%
ungroup()%>% dplyr::select(age, setting, RCT, PR_obs_min_baseline, PR_obs_max_baseline, PR_obs_baseline)%>%
unique()%>%
left_join(validat_pooledAll  %>% select(-setting0)%>% unique())%>%
mutate(effect_size_obs=100*(PR_obs_baseline-PR_obs)/PR_obs_baseline)
reg_before_after_match=before_after_data %>% left_join(before_after_match_pool) %>% select(RCT, year, month, setting,effect_size, effect_size_obs )
model_before_after <- lm(effect_size_obs ~ effect_size +0,
data=reg_before_after_match)
summary(model_before_after)
Rsquared_before_after <- round(summary(model_before_after)$adj.r.squared,2)
Rsquared_before_after
slope_before_after<- round(summary(model_before_after)$coefficients[1],2)
scatter_before_after=before_after_data %>% left_join(before_after_match_pool) %>%
ggplot()+
geom_point(aes(y=effect_size, x=effect_size_obs, color=setting, shape=RCT), size=2)+
scale_color_manual(values=c("darkgrey", "dodgerblue","orange"))+#xlim(-10,100)+ ylim(0,100)+
geom_abline(slope=1, intercept = 0, linetype="dashed")+
#geom_abline(slope=slope_before_after, intercept = 0)+
theme_minimal()+#xlim(0,100)+ylim(0,100)+
labs(color="", y='Modelled reduction to baseline', x="Observed reduction to baseline",shape="")+
theme(legend.position = "right")
my_parameter_GVI=read.csv("/Users/chamcl/Documents/git_repositories/ig2/GITHUB-final/EHT_fit/fitted_parameters_posteriormax.csv")
my_parameter_GVI=read.csv("/Users/chamcl/Documents/git_repositories/ig2/GITHUB-final/EHT_fit/fitted_parameters_posteriormax.csv")
View(my_parameter_GVI)
# Update halflife of the net to include insecticide decay from EHT data
update_halflife_insecticideDecay=function(my_parameters_GVI, halflife, kappa, my_EHT, my_netType, insecticide_decay){
this.parameters_GVI=my_parameters_GVI%>%
filter(netType %in% c(my_netType, "control"), EHT==my_EHT)%>%
mutate(L_functionalSurvival=halflife,
kappa_functionalSurvival=kappa)
if(insecticide_decay){
df=data.frame(time=seq(0, 365*3))%>%
mutate( weibull=exp( -(time/halflife)^kappa * log(2) ))
for(i in 1:nrow(this.parameters_GVI)){
this.line=this.parameters_GVI[i,]
if(is.na(this.line$halflife_insecticide) | this.line$halflife_insecticide<0 ){
this.parameters_GVI$final_hl[i]=halflife
this.parameters_GVI$final_kappa[i]=kappa
} else {
this.df=df %>% mutate(
linear= 1-time/this.line$halflife_insecticide,
ITNcov=weibull*linear, setting="test")
product_fit=calculate_param("test", opti_fun="weibull", df=this.df)
this.parameters_GVI$final_hl[i]=round(product_fit$L, digits = 1)
this.parameters_GVI$final_kappa[i]=round(product_fit$k, digits = 1)
this.df=NULL
}
}
} else{
this.parameters_GVI=this.parameters_GVI%>%
mutate(final_hl=halflife,
final_kappa=kappa)
}
return(this.parameters_GVI)
}
library(dplyr)
my_parameter_GVI=read.csv("/Users/chamcl/Documents/git_repositories/ig2/GITHUB-final/EHT_fit/fitted_parameters_posteriormax.csv")
# Update halflife of the net to include insecticide decay from EHT data
update_halflife_insecticideDecay=function(my_parameters_GVI, halflife, kappa, my_EHT, my_netType, insecticide_decay){
this.parameters_GVI=my_parameters_GVI%>%
filter(netType %in% c(my_netType, "control"), EHT==my_EHT)%>%
mutate(L_functionalSurvival=halflife,
kappa_functionalSurvival=kappa)
if(insecticide_decay){
df=data.frame(time=seq(0, 365*3))%>%
mutate( weibull=exp( -(time/halflife)^kappa * log(2) ))
for(i in 1:nrow(this.parameters_GVI)){
this.line=this.parameters_GVI[i,]
if(is.na(this.line$halflife_insecticide) | this.line$halflife_insecticide<0 ){
this.parameters_GVI$final_hl[i]=halflife
this.parameters_GVI$final_kappa[i]=kappa
} else {
this.df=df %>% mutate(
linear= 1-time/this.line$halflife_insecticide,
ITNcov=weibull*linear, setting="test")
product_fit=calculate_param("test", opti_fun="weibull", df=this.df)
this.parameters_GVI$final_hl[i]=round(product_fit$L, digits = 1)
this.parameters_GVI$final_kappa[i]=round(product_fit$k, digits = 1)
this.df=NULL
}
}
} else{
this.parameters_GVI=this.parameters_GVI%>%
mutate(final_hl=halflife,
final_kappa=kappa)
}
return(this.parameters_GVI)
}
update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Kibondo", my_netType="Interceptor G2", insecticide_decay=T)
calculate_param=function(insecticide, opti_fun="weibull", df){
opti_function=ifelse(opti_fun=="weibull", optimise_decay_param, optimise_decay_param_hill)
opti=optim(c(0.448, 1.11, 0.7), opti_function, insecticide=insecticide, df=df , method = "L-BFGS-B", lower=c(0, 0, 0), upper = c(Inf, Inf, 1) )$par
names(opti)=c("L", "k", "a")
opti$setting=insecticide
opti$decay=opti_fun
return(opti)
}
# Update halflife of the net to include insecticide decay from EHT data
update_halflife_insecticideDecay=function(my_parameters_GVI, halflife, kappa, my_EHT, my_netType, insecticide_decay){
this.parameters_GVI=my_parameters_GVI%>%
filter(netType %in% c(my_netType, "control"), EHT==my_EHT)%>%
mutate(L_functionalSurvival=halflife,
kappa_functionalSurvival=kappa)
if(insecticide_decay){
df=data.frame(time=seq(0, 365*3))%>%
mutate( weibull=exp( -(time/halflife)^kappa * log(2) ))
for(i in 1:nrow(this.parameters_GVI)){
this.line=this.parameters_GVI[i,]
if(is.na(this.line$halflife_insecticide) | this.line$halflife_insecticide<0 ){
this.parameters_GVI$final_hl[i]=halflife
this.parameters_GVI$final_kappa[i]=kappa
} else {
this.df=df %>% mutate(
linear= 1-time/this.line$halflife_insecticide,
ITNcov=weibull*linear, setting="test")
product_fit=calculate_param("test", opti_fun="weibull", df=this.df)
this.parameters_GVI$final_hl[i]=round(product_fit$L, digits = 1)
this.parameters_GVI$final_kappa[i]=round(product_fit$k, digits = 1)
this.df=NULL
}
}
} else{
this.parameters_GVI=this.parameters_GVI%>%
mutate(final_hl=halflife,
final_kappa=kappa)
}
return(this.parameters_GVI)
}
update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Kibondo", my_netType="Interceptor G2", insecticide_decay=T)
library(dplyr)
my_parameter_GVI=read.csv("/Users/chamcl/Documents/git_repositories/ig2/GITHUB-final/EHT_fit/fitted_parameters_posteriormax.csv")
calculate_param=function(insecticide, opti_fun="weibull", df){
opti_function=ifelse(opti_fun=="weibull", optimise_decay_param, optimise_decay_param_hill)
opti=optim(c(0.448, 1.11, 0.7), opti_function, insecticide=insecticide, df=df , method = "L-BFGS-B", lower=c(0, 0, 0), upper = c(Inf, Inf, 1) )$par
names(opti)=c("L", "k", "a")
opti$setting=insecticide
opti$decay=opti_fun
return(opti)
}
# Update halflife of the net to include insecticide decay from EHT data
update_halflife_insecticideDecay=function(my_parameters_GVI, halflife, kappa, my_EHT, my_netType, insecticide_decay){
this.parameters_GVI=my_parameters_GVI%>%
filter(netType %in% c(my_netType, "control"), EHT==my_EHT)%>%
mutate(L_functionalSurvival=halflife,
kappa_functionalSurvival=kappa)
if(insecticide_decay){
df=data.frame(time=seq(0, 365*3))%>%
mutate( weibull=exp( -(time/halflife)^kappa * log(2) ))
for(i in 1:nrow(this.parameters_GVI)){
this.line=this.parameters_GVI[i,]
if(is.na(this.line$halflife_insecticide) | this.line$halflife_insecticide<0 ){
this.parameters_GVI$final_hl[i]=halflife
this.parameters_GVI$final_kappa[i]=kappa
} else {
this.df=df %>% mutate(
linear= 1-time/this.line$halflife_insecticide,
ITNcov=weibull*linear, setting="test")
product_fit=calculate_param("test", opti_fun="weibull", df=this.df)
this.parameters_GVI$final_hl[i]=round(product_fit$L, digits = 1)
this.parameters_GVI$final_kappa[i]=round(product_fit$k, digits = 1)
this.df=NULL
}
}
} else{
this.parameters_GVI=this.parameters_GVI%>%
mutate(final_hl=halflife,
final_kappa=kappa)
}
return(this.parameters_GVI)
}
# function to refit weibull decay
optimise_decay_param=function(param, insecticide, df){
#if(param[3]<1){
out=data.frame(
time=df %>% filter(setting==insecticide) %>% pull(time),
decay_obs=df %>% filter(setting==insecticide) %>% pull(ITNcov)
)%>%
mutate(decay=param[3]*exp( -(time/(param[1]))^param[2] * log(2) ),
diff=(decay-decay_obs)^2)%>%
summarise(diff=sum(diff))
return(out)
}
update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Kibondo", my_netType="Interceptor G2", insecticide_decay=T)
update_halflife_insecticideDecay
output=update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Kibondo", my_netType="Interceptor G2", insecticide_decay=T)
output
output=update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Martin", my_netType="Interceptor G2", insecticide_decay=T)
output
output=update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Assenga", my_netType="Interceptor G2", insecticide_decay=T)
output
output=update_halflife_insecticideDecay(my_parameters_GVI=my_parameter_GVI,
halflife=2.4, kappa=2,
my_EHT="Assenga", my_netType="Pyrethroid-only", insecticide_decay=T)
output
128.20/2
- [AnophelesModel](https://github.com/SwissTPH/AnophelesModel/tree/main), version 1.1.0 and later
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
mainDir="."
scriptDir=file.path(".","EHT_fit")
stanDir=file.path(mainDir, "results/stan_outputs")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
mainDir="."
scriptDir=file.path(".","EHT_fit")
stanDir=file.path(mainDir, "results/stan_outputs")
plotDir=file.path(mainDir, "plots")
dataDir=file.path(scriptDir, "processed_data")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
#mainDir="."
mainDir="/Users/chamcl/switchdrive/AIM//5. Collaborations/External/Pie & Sarah/EHT_Fitting/"
#scriptDir=file.path(mainDir,"EHT_fit")
scriptDir="/Users/chamcl/Documents/git_repositories/ig2/GITHUB/EHT_fit/"
stanDir=file.path(mainDir, "results/stan_outputs")
plotDir=file.path(mainDir, "../Write-up/Revision/plots")
dataDir=file.path(scriptDir, "processed_data")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
niter=6000
nwarmup=3000
nchains=3
mu_0=0.14
alpha_0=0.15
pc_0=0.92
pi=0.69
kappa=3.8
xi=0.52
return_proba=function(alpha, mu, pc){
proba=c(exp(-alpha-mu),
(1-exp(-alpha-mu))*mu/(alpha+mu),
(1-exp(-alpha-mu))*alpha/(alpha+mu)*pc,
(1-exp(-alpha-mu))*alpha/(alpha+mu)*(1-pc))
names(proba)=c("UA", "UD", "FD", "FA")
return(proba)
}
proba_control=return_proba(alpha_0, mu_0, pc_0)
proba_i=return_proba(alpha_0*(1-pi), mu_0+alpha_0*kappa, pc_0*(1-xi))
n_samples=200
sample_control=data.frame(t(rmultinom(n_samples,4, proba_control)))
sample_i=data.frame(t(rmultinom(n_samples,4, proba_i)))
simulated_data=rbind(sample_control %>% mutate(treatment=0, insecticide_name="control"),
sample_i %>% mutate(treatment=1, insecticide_name="newITN"))%>%
mutate(fed=FA+FD, total=UA+UD+FA+FD)
fit_EHT_multinomial_stan(data=simulated_data,
iter=niter,
warmup=nwarmup,
chains=nchains,
path=file.path(stanDir,"/stan_simulated_data.rds"),
stanpath = scriptDir, stanmodel = "EHT_fitting_model.stan")
return_proba=function(alpha, mu, pc){
proba=c(exp(-alpha-mu),
(1-exp(-alpha-mu))*mu/(alpha+mu),
(1-exp(-alpha-mu))*alpha/(alpha+mu)*pc,
(1-exp(-alpha-mu))*alpha/(alpha+mu)*(1-pc))
names(proba)=c("UA", "UD", "FA", "FD")
return(proba)
}
proba_control=return_proba(alpha_0, mu_0, pc_0)
proba_i=return_proba(alpha_0*(1-pi), mu_0+alpha_0*kappa, pc_0*(1-xi))
n_samples=200
sample_control=data.frame(t(rmultinom(n_samples,4, proba_control)))
sample_i=data.frame(t(rmultinom(n_samples,4, proba_i)))
simulated_data=rbind(sample_control %>% mutate(treatment=0, insecticide_name="control"),
sample_i %>% mutate(treatment=1, insecticide_name="newITN"))%>%
mutate(fed=FA+FD, total=UA+UD+FA+FD)
fit_EHT_multinomial_stan(data=simulated_data,
iter=niter,
warmup=nwarmup,
chains=nchains,
path=file.path(stanDir,"/stan_simulated_data.rds"),
stanpath = scriptDir, stanmodel = "EHT_fitting_model.stan")
results_simulated<- readRDS(file.path(stanDir,"stan_simulated_data.rds"))
estimates_simulated=get_stan_summary_output(results_simulated, decay="none",
save=FALSE,
path=NULL, data=simulated_data)
map_simulated=extract_stan_posteriormax(results_simulated,  data=simulated_data)
map_simulated
n_samples=1000
sample_control=data.frame(t(rmultinom(n_samples,4, proba_control)))
sample_i=data.frame(t(rmultinom(n_samples,4, proba_i)))
simulated_data=rbind(sample_control %>% mutate(treatment=0, insecticide_name="control"),
sample_i %>% mutate(treatment=1, insecticide_name="newITN"))%>%
mutate(fed=FA+FD, total=UA+UD+FA+FD)
fit_EHT_multinomial_stan(data=simulated_data,
iter=niter,
warmup=nwarmup,
chains=nchains,
path=file.path(stanDir,"/stan_simulated_data.rds"),
stanpath = scriptDir, stanmodel = "EHT_fitting_model.stan")
results_simulated<- readRDS(file.path(stanDir,"stan_simulated_data.rds"))
estimates_simulated=get_stan_summary_output(results_simulated, decay="none",
save=FALSE,
path=NULL, data=simulated_data)
map_simulated=extract_stan_posteriormax(results_simulated,  data=simulated_data)
map_simulated
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
mainDir="."
scriptDir=file.path(".","EHT_fit")
stanDir=file.path(mainDir, "results/stan_outputs")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
mainDir="."
scriptDir=file.path(".","EHT_fit")
stanDir=file.path(mainDir, "results/stan_outputs")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
mainDir="."
scriptDir=file.path(".","EHT_fit")
stanDir=file.path(mainDir, "results/stan_outputs")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
rm(list=ls())
library(dplyr)
library(stringr)
library(tidyr)
library(rstan)
#mainDir="."
mainDir="/Users/chamcl/switchdrive/AIM//5. Collaborations/External/Pie & Sarah/EHT_Fitting/"
#scriptDir=file.path(mainDir,"EHT_fit")
scriptDir="/Users/chamcl/Documents/git_repositories/ig2/GITHUB/EHT_fit/"
stanDir=file.path(mainDir, "results/stan_outputs")
plotDir=file.path(mainDir, "../Write-up/Revision/plots")
dataDir=file.path(scriptDir, "processed_data")
outputsDir=file.path(mainDir, "results/csv_outputs")
source(file.path(scriptDir, "functions_fit_stan.R"))
niter=6000
nwarmup=3000
nchains=3
rerun=FALSE
niter=1000
nwarmup=500
nchains=3
rerun=FALSE
mu_0=0.14
alpha_0=0.15
pc_0=0.92
pi=0.69
kappa=3.8
xi=0.52
return_proba=function(alpha, mu, pc){
proba=c(exp(-alpha-mu),
(1-exp(-alpha-mu))*mu/(alpha+mu),
(1-exp(-alpha-mu))*alpha/(alpha+mu)*pc,
(1-exp(-alpha-mu))*alpha/(alpha+mu)*(1-pc))
names(proba)=c("UA", "UD", "FA", "FD")
return(proba)
}
proba_control=return_proba(alpha_0, mu_0, pc_0)
proba_i=return_proba(alpha_0*(1-pi), mu_0+alpha_0*kappa, pc_0*(1-xi))
n_samples=1000
sample_control=data.frame(t(rmultinom(n_samples,4, proba_control)))
sample_i=data.frame(t(rmultinom(n_samples,4, proba_i)))
simulated_data=rbind(sample_control %>% mutate(treatment=0, insecticide_name="control"),
sample_i %>% mutate(treatment=1, insecticide_name="newITN"))%>%
mutate(fed=FA+FD, total=UA+UD+FA+FD)
fit_EHT_multinomial_stan(data=simulated_data,
iter=niter,
warmup=nwarmup,
chains=nchains,
path=file.path(stanDir,"/stan_simulated_data.rds"),
stanpath = scriptDir, stanmodel = "EHT_fitting_model.stan")
results_simulated<- readRDS(file.path(stanDir,"stan_simulated_data.rds"))
estimates_simulated=get_stan_summary_output(results_simulated, decay="none",
save=FALSE,
path=NULL, data=simulated_data)
map_simulated=extract_stan_posteriormax(results_simulated,  data=simulated_data)
shiny::runApp('git_repositories/GitHubRepos/ITNcascades/ITNcascadesdashboard')
